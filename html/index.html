<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/svg+xml" href="/favicon.svg">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

  <title>DeadSFU</title>

  <style>
    /* .nav-item a:hover {  cursor: pointer }  */
    /* .nav-link a:hover { cursor: crosshair;} */
    /* this somehow changes the cursor over links in the navbar */
    /* a.nav-link {
      cursor: default;
    } */

    a {
      color: #0053fa;

      background-color: transparent;
      text-decoration: none;
    }

    /* override bootstrap button color */
    .btn-primary,
    .btn-primary:hover,
    .btn-primary:active,
    .btn-primary:visited {
      background-color: #0053fa !important;
    }
  </style>
</head>

<body>

  <div class="container">
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <div class="container-fluid">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarTogglerDemo01"
          aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse my-1" id="navbarTogglerDemo01">
          <a class="navbar-brand" href="#" style="color: #0053fa;">
            <span>
              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewbox="0 0 473.654 473.654"
                style="vertical-align:-6;enable-background:new 0 0 473.654 473.654;" xml:space="preserve" width="25px"
                height="25px">
                <circle style="fill:#0053fa;" cx="236.827" cy="236.827" r="236.827" />
                <path style="fill:#FFFFFF;"
                  d="M417.235,184.185c-1.339-1.47-3.272-2.367-5.632-2.169c-0.632,0.015-1.253,0.108-1.851,0.295
    c-25.504,5.452-51.004,10.905-76.508,16.353c-5.299,1.137-6.724,8.156-3.115,11.761c6.754,6.754,13.504,13.504,20.257,20.257
    c-31.708,31.704-63.412,63.408-95.116,95.116c0-53.382,0-106.769,0-160.147c9.648,0,19.292,0,28.937,0
    c5.149,0,9.061-5.991,6.099-10.561c-14.192-21.903-28.383-43.805-42.575-65.704c-0.12-0.224-0.266-0.43-0.411-0.639
    c-0.011-0.019-0.022-0.037-0.037-0.056c-0.011-0.015-0.022-0.026-0.034-0.045c-0.157-0.217-0.314-0.423-0.497-0.621
    c-1.537-1.9-3.586-2.655-5.609-2.55c-1.978-0.049-3.968,0.748-5.464,2.61c-0.116,0.127-0.217,0.266-0.322,0.404
    c-0.064,0.086-0.135,0.15-0.194,0.239c-0.082,0.131-0.168,0.258-0.251,0.389c-0.034,0.056-0.075,0.101-0.105,0.157
    c-14.218,21.951-28.436,43.899-42.657,65.85c-2.894,4.473,0.939,10.519,6.021,10.519c9.682,0,19.364,0,29.045,0
    c0,53.308,0,106.615,0,159.923c-31.513-31.513-63.027-63.027-94.536-94.536c6.885-6.885,13.773-13.773,20.661-20.657
    c3.571-3.571,2.079-10.583-3.134-11.697c-25.549-5.46-51.098-10.92-76.646-16.376c-0.553-0.165-1.133-0.247-1.72-0.266
    c-2.315-0.198-4.233,0.654-5.576,2.064c-1.462,1.331-2.36,3.261-2.169,5.613c0.011,0.647,0.108,1.275,0.299,1.881
    c5.449,25.496,10.901,51,16.349,76.497c1.133,5.299,8.152,6.724,11.757,3.119c6.78-6.78,13.56-13.56,20.34-20.34
    c39.415,39.415,78.83,78.83,118.245,118.245c3.328,3.328,7.12,4.405,10.695,4.001c3.354,0.142,6.855-1.017,9.944-4.11
    c39.497-39.497,78.995-78.995,118.492-118.496c6.914,6.918,13.833,13.829,20.747,20.747c3.571,3.571,10.583,2.083,11.694-3.134
    c5.456-25.549,10.912-51.094,16.368-76.643c0.165-0.553,0.251-1.137,0.269-1.724C419.494,187.442,418.645,185.524,417.235,184.185z" />
              </svg>
              DeadSFU
            </span>
          </a>
  
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <button type="button" class="mx-1 my-1 btn btn-primary active" aria-current="page">Send</button>
            </li>
            <li class="nav-item">
              <button type="button" class="mx-1 my-1 btn btn-primary">Receive</button>
            </li>
  
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle xdisabled my-1" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-disabled="true" aria-expanded="false">
                Channel
              </a>
              <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                <li><a class="dropdown-item" href="#">Action</a></li>
                <li><a class="dropdown-item" href="#">Another action</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#">Something else here</a></li>
              </ul>
            </li>
          </ul>
  
          <form class="d-flex">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
  
              <span id="rxtx" class="navbar-text me-2"> 0/0 rx/tx kbps </span>
  
              <span id="xstate" class="navbar-text">disconnected</span>
  
              <li class="nav-item">
                <a class="nav-link" style="color: #0053fa;" href="#" tabindex="-1" aria-disabled="true">Help</a>
              </li>
  
            </ul>
          </form>
        </div>
      </div>
    </nav>



  <br />





    <figure class="image is-16by9 text-center">
      <!-- removing muted means Safari (maybe others will be black/worn autoplay) -->
      <!-- you should keep muted attribute present-->
      <!-- controls helps user turn on audio -->

      <video id="video1" autoplay controls muted class="has-ratio" width="1024" frameborder="2" poster="cam.svg"
        allowfullscreen style="background-color: #0053fa;">
      </video>
    </figure>

  </div>


  <script>
    //The @ts-check statement enables jsdoc typechecking
    // https://stackoverflow.com/a/52076280/86375
    // http://demo.unified-streaming.com/players/dash.js-2.4.1/build/jsdoc/jsdoc_cheat-sheet.pdf
    //@ts-check
    const txid = rand64Hex()

    let suburl = location.origin + '/sub'        // output from sfu
    let puburl = location.origin + '/pub'          // input to sfu


    function rand64Hex() {
      var buffer = new Uint8Array(8)
      window.crypto.getRandomValues(buffer)
      return Array.prototype.map.call(new Uint8Array(buffer), x => ('0' + x.toString(16)).slice(-2)).join('');
    }


    async function level(ll) {
      const url = suburl + '?txid=' + txid + '&level=' + ll
      console.debug('before level fetch')
      fetch(url)
    }


    async function transmit() {
      console.log("--transmit5")


      try {
        const gumopts = { video: { width: 1280, height: 720 }, audio: true }
        const stream = await navigator.mediaDevices.getUserMedia(gumopts)

        const xvid = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
        xvid.srcObject = stream
        //   var t0 = performance.now()
        //console.debug("delay of " + (performance.now() - t0) + "ms")
        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)
        const xstate = document.getElementById('xstate')
        pc.onconnectionstatechange = e => xstate.innerText = pc.connectionState
        //pc.onicecandidate = event => { console.debug('ignore ice candidate') }


        //track.applyConstraints({ frameRate: { min: 30, max: 30 } });
        let simulcast = true
        if (simulcast) {
          pc.addTransceiver(stream.getVideoTracks()[0], {
            //cam sendrecv will not fix rids Ontrack bug
            direction: 'sendonly',
            streams: [stream],
            sendEncodings: [
              // for firefox order matters... first high resolution, then scaled resolutions...
              {
                rid: 'video2',
                scaleResolutionDownBy: 4.0
              },
              {
                rid: 'video1',
                scaleResolutionDownBy: 2.0
              },
              {
                rid: 'video0'
              },
            ],
          });
          //the original added three tx's here for the return streams
          // for the sample
          // they did not nave sendonly, but could have I believe
          // leaving this transciver in, even though
          // it is not needed fixes the 
          // OnTrack callback issue
          //pc.addTransceiver('video', { 'direction': 'sendonly' })
          // pc.addTransceiver('video', {'direction': 'sendonly'})
          // pc.addTransceiver('video', {'direction': 'sendonly'})
        } else {
          pc.addTransceiver(stream.getVideoTracks()[0], { 'direction': 'sendonly' })
        }
        pc.addTransceiver(stream.getAudioTracks()[0], { 'direction': 'sendonly' })

        // Older firefox technique for simulcast from Janus blog
        // var sender = pc.getSenders().find(s => s.track.kind == "video");
        // var parameters = sender.getParameters();
        // if (!parameters)
        //     parameters = {};
        // parameters.encodings = [
        //     { rid: "h", active: true, maxBitrate: 900000 },
        //     { rid: "m", active: true, maxBitrate: 300000, scaleResolutionDownBy: 2 },
        //     { rid: "l", active: true, maxBitrate: 100000, scaleResolutionDownBy: 4 }
        // ];
        // sender.setParameters(parameters);

        let desc = await pc.createOffer()
        await pc.setLocalDescription(desc)

        // XXXX consider wrapping with timeout promise
        const t0 = performance.now()
        await waitToCompleteIceGathering(pc)
        desc = pc.localDescription
        console.debug('ice gather blocked for N ms:', Math.ceil(performance.now() - t0))

        console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        let fetchopt =
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp', },
          body: desc.sdp
        }
        let resp = await fetch(puburl, fetchopt)
        let resptext = await resp.text()
        if (resp.status != 202) {
          console.error('sfu http error', resp.status, resptext)
          pc.close()
          return
        }
        console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)
        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        while (true) {
          document.getElementById('rxtx').innerText = await getRxTxRate(pc)
          await new Promise(r => setTimeout(r, 3000))
        }

      } catch (error) {
        console.error('pub error', error)
      }
    }


    function waitToCompleteIceGathering(pc) {
      return new Promise(resolve => {
        setTimeout(function () {
          resolve(pc.localDescription)
        }, 250)
        pc.addEventListener('icegatheringstatechange', e => (e.target.iceGatheringState === 'complete') && resolve(pc.localDescription));
      });
    }

    async function receive() {
      console.log("--receive x3")

      try {
        const url = suburl + '?txid=' + txid

        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)
        const xstate = document.getElementById('xstate')
        pc.onconnectionstatechange = e => xstate.innerText = pc.connectionState
        //pc.onicecandidate = event => { console.debug('ignore ice candidate') }

        //must have addtransceiver to get m=video in sdp
        //addTransceiver() must be called before createOffer()
        // also, we need to note, the sfu will add 3x video tx
        // while we only add 1x video tx
        // the sfu will use this fact to decide 
        // whether to allow switching of the first video track
        //
        pc.addTransceiver('video', { 'direction': 'recvonly' })
        pc.addTransceiver('audio', { 'direction': 'recvonly' })

        let desc = await pc.createOffer()
        await pc.setLocalDescription(desc)
        // XXXX consider wrapping with timeout promise
        const t0 = performance.now()
        await waitToCompleteIceGathering(pc)
        desc = pc.localDescription
        console.debug('ice gather blocked for N ms:', Math.ceil(performance.now() - t0))

        //console.debug('got all ice ms:', performance.now() - t0)

        console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        let fetchopt =
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp', },
          body: desc.sdp
        }
        let resp = await fetch(url, fetchopt)
        let resptext = await resp.text()
        if (resp.status != 202) {
          console.error('sfu http error', resp.status, resptext)
          pc.close()
          return
        }
        console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)


        pc.ontrack = function (event) {
          let z = event.streams[0]
          console.debug('on track fired naudio', z.getAudioTracks().length)
          console.debug('on track fired nvideo', z.getVideoTracks().length)
          const xvid = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
          xvid.srcObject = event.streams[0]
          xvid.autoplay = true
          xvid.controls = true
          return false
        }

        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        console.debug('n senders in getsenders()', pc.getSenders())
        //NO NO
        // pc.addTransceiver('audio', { 'direction': 'recvonly' })
        // pc.addTransceiver('video', { 'direction': 'recvonly' })

        while (true) {
          document.getElementById('rxtx').innerText = await getRxTxRate(pc)
          await new Promise(r => setTimeout(r, 3000))
        }


      } catch (error) {
        console.error('Error:', error)
        alert('Error:' + error)
      }
    }

    var ratemap = new Map()

    async function getRxTxRate(pc) {
      let rxrate = 0
      let txrate = 0
      try {
        if (typeof ratemap === 'undefined') {
          ratemap = new Map()
        }

        const results = await pc.getStats(null)
        results.forEach(report => {
          const now = report.timestamp

          //debugging notes
          // if (typeof report.bytesReceived !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesReceived)
          // }
          // if (typeof report.bytesTransmitted !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesTransmitted)
          // }

          if (report.type === 'outbound-rtp') {
            const bytes = report.bytesSent
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              txrate += bitrate
              //console.debug('tx speed', report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
          if (report.type === 'inbound-rtp') {
            const bytes = report.bytesReceived
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              rxrate += bitrate
              //console.debug('rx speed',report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
        })

      } catch (err) {
        console.error(err);
      }
      // we have kbps
      rxrate = Math.floor(rxrate)
      txrate = Math.floor(txrate)

      return `${rxrate}/${txrate} rx/tx kbps`
    }

  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
    crossorigin="anonymous"></script>
</body>

</html>