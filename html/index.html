<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">

  <title>SFU1</title>

  <style>
    /* .nav-item a:hover {  cursor: pointer }  */
    /* .nav-link a:hover { cursor: crosshair;} */
    a.nav-link {
      cursor: default;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Navbar</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"
        aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
        <div class="navbar-nav">
          <a class="nav-link active" aria-current="page" onclick="transmit()">TX</a>
          <a class="nav-link" href="#">Features</a>
          <a class="nav-link" href="#">Pricing</a>
          <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>
        </div>
      </div>
    </div>
  </nav>


  <div class="container">
    
      <figure class="image is-16by9 text-center">
        <!-- removing muted means Safari (maybe others will be black/worn autoplay) -->
        <!-- you should keep muted attribute present-->
        <!-- controls helps user turn on audio -->

        <video id="video1" autoplay controls muted class="has-ratio" width="1024" frameborder="2"
          poster="https://x186k.org/x186k.png" allowfullscreen
          style="background-color: rgb(187, 64, 64);"
          >
        </video>
      </figure>
  
  </div>


  <script>
    //The @ts-check statement enables jsdoc typechecking
    // https://stackoverflow.com/a/52076280/86375
    // http://demo.unified-streaming.com/players/dash.js-2.4.1/build/jsdoc/jsdoc_cheat-sheet.pdf
    //@ts-check
    const txid = longRandomString()

    let suburl = location.origin + '/sub'        // output from sfu
    let puburl = location.origin + '/pub'          // input to sfu


    function longRandomString() {
      var buffer = new Uint8Array(10)
      window.crypto.getRandomValues(buffer)
      return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
    }


    async function level(ll) {
      const url = suburl + '?txid=' + txid + '&level=' + ll
      console.debug('before level fetch')
      fetch(url)
    }


    async function transmit() {
      console.log("--transmit5")


      try {
        const gumopts = { video: { width: 1280, height: 720 }, audio: true }
        const stream = await navigator.mediaDevices.getUserMedia(gumopts)

        const xvid = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
        xvid.srcObject = stream
        //   var t0 = performance.now()
        //console.debug("delay of " + (performance.now() - t0) + "ms")
        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)
        //pc.onicecandidate = event => { console.debug('ignore ice candidate') }


        const track = stream.getVideoTracks()[0];
        //track.applyConstraints({ frameRate: { min: 30, max: 30 } });
        let simulcast = true
        if (simulcast) {
          pc.addTransceiver(track, {
            //cam sendrecv will not fix rids Ontrack bug
            direction: 'sendonly',
            streams: [stream],
            sendEncodings: [
              // for firefox order matters... first high resolution, then scaled resolutions...
              {
                rid: 'video2',
                scaleResolutionDownBy: 4.0
              },
              {
                rid: 'video1',
                scaleResolutionDownBy: 2.0
              },
              {
                rid: 'video0'
              },
            ],
          });
          //the original added three tx's here for the return streams
          // for the sample
          // they did not nave sendonly, but could have I believe
          // leaving this transciver in, even though
          // it is not needed fixes the 
          // OnTrack callback issue
          //pc.addTransceiver('video', { 'direction': 'sendonly' })
          // pc.addTransceiver('video', {'direction': 'sendonly'})
          // pc.addTransceiver('video', {'direction': 'sendonly'})
        } else {
          pc.addTransceiver(stream.getVideoTracks()[0], { 'direction': 'sendonly' })
        }
        pc.addTransceiver(stream.getAudioTracks()[0], { 'direction': 'sendonly' })

        // Older firefox technique for simulcast from Janus blog
        // var sender = pc.getSenders().find(s => s.track.kind == "video");
        // var parameters = sender.getParameters();
        // if (!parameters)
        //     parameters = {};
        // parameters.encodings = [
        //     { rid: "h", active: true, maxBitrate: 900000 },
        //     { rid: "m", active: true, maxBitrate: 300000, scaleResolutionDownBy: 2 },
        //     { rid: "l", active: true, maxBitrate: 100000, scaleResolutionDownBy: 4 }
        // ];
        // sender.setParameters(parameters);

        let desc = await pc.createOffer()
        await pc.setLocalDescription(desc)


        console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        let fetchopt =
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp', },
          body: desc.sdp
        }
        let resp = await fetch(puburl, fetchopt)
        let resptext = await resp.text()
        if (resp.status != 202) {
          console.error('sfu http error', resp.status, resptext)
          pc.close()
          return
        }
        console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)
        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        while (true) {
          document.getElementById('rxtx').innerText = await getRxTxRate(pc)
          await new Promise(r => setTimeout(r, 3000))
        }

      } catch (error) {
        console.error('pub error', error)
      }
    }


    async function receive() {
      console.log("--receive x3")

      try {
        const url = suburl + '?txid=' + txid

        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)
        //pc.onicecandidate = event => { console.debug('ignore ice candidate') }

        //must have addtransceiver to get m=video in sdp
        //addTransceiver() must be called before createOffer()
        // also, we need to note, the sfu will add 3x video tx
        // while we only add 1x video tx
        // the sfu will use this fact to decide 
        // whether to allow switching of the first video track
        //
        pc.addTransceiver('video', { 'direction': 'recvonly' })
        pc.addTransceiver('audio', { 'direction': 'recvonly' })

        let desc = await pc.createOffer()

        //xxxxx




        await pc.setLocalDescription(desc)




        //  pc.addTransceiver('audio')//{ 'direction': 'recvonly' })



        console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        let fetchopt =
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp', },
          body: desc.sdp
        }
        let resp = await fetch(url, fetchopt)
        let resptext = await resp.text()
        if (resp.status != 202) {
          console.error('sfu http error', resp.status, resptext)
          pc.close()
          return
        }
        console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)


        pc.ontrack = function (event) {
          let z = event.streams[0]
          console.debug('on track fired naudio', z.getAudioTracks().length)
          console.debug('on track fired nvideo', z.getVideoTracks().length)
          const xvid = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
          xvid.srcObject = event.streams[0]
          xvid.autoplay = true
          xvid.controls = true
          return false
        }

        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        console.debug('n senders in getsenders()', pc.getSenders())
        //NO NO
        // pc.addTransceiver('audio', { 'direction': 'recvonly' })
        // pc.addTransceiver('video', { 'direction': 'recvonly' })

        while (true) {
          document.getElementById('rxtx').innerText = await getRxTxRate(pc)
          await new Promise(r => setTimeout(r, 3000))
        }


      } catch (error) {
        console.error('receive error', error)
      }
    }

    var ratemap = new Map()

    async function getRxTxRate(pc) {
      let rxrate = 0
      let txrate = 0
      try {
        if (typeof ratemap === 'undefined') {
          ratemap = new Map()
        }

        const results = await pc.getStats(null)
        results.forEach(report => {
          const now = report.timestamp

          //debugging notes
          // if (typeof report.bytesReceived !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesReceived)
          // }
          // if (typeof report.bytesTransmitted !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesTransmitted)
          // }

          if (report.type === 'outbound-rtp') {
            const bytes = report.bytesSent
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              txrate += bitrate
              //console.debug('tx speed', report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
          if (report.type === 'inbound-rtp') {
            const bytes = report.bytesReceived
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              rxrate += bitrate
              //console.debug('rx speed',report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
        })

      } catch (err) {
        console.error(err);
      }
      // we have kbps
      rxrate = Math.floor(rxrate)
      txrate = Math.floor(txrate)

      return `${rxrate}/${txrate} rx/tx kbps`
    }

  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0"
    crossorigin="anonymous"></script>
</body>

</html>