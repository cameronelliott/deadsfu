<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" type="image/svg+xml" href="/favicon.svg">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

  <title>Console</title>

  <style>
    /* .nav-item a:hover {  cursor: pointer }  */
    /* .nav-link a:hover { cursor: crosshair;} */
    /* this somehow changes the cursor over links in the navbar */
    /* a.nav-link {
      cursor: default;
    } */

    a {
      color: #0053fa;

      background-color: transparent;
      text-decoration: none;
    }

    /* override bootstrap button color */
    .btn-primary,
    .btn-primary:hover,
    .btn-primary:active,
    .btn-primary:visited {
      background-color: #0053fa !important;
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- As a heading -->
    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="mx-auto order-0">
          <span class="navbar-text">
            <a id="gofullscreen" style="color: #0053fa;" href="#" tabindex="-1" aria-disabled="true">
              <svg height="1em" width="1em" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="expand"
                class="svg-inline--fa fa-expand fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg"
                viewbox="0 0 448 512">
                <path fill="currentColor"
                  d="M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z">
                </path>
              </svg></a>
          </span>
          &nbsp;&nbsp;&nbsp;
          <span id="rxtx" class="navbar-text me-2"> 0/0 rx/tx kbps </span>
          &nbsp;&nbsp;&nbsp;
          <span id="xstate" class="navbar-text">disconnected</span>
          &nbsp;&nbsp;&nbsp;
          <span class="navbar-text">
            <a style="color: #0053fa;" href="#" tabindex="-1" aria-disabled="true">help</a>
          </span>
        </div>

      </nav>
    </div>


    <!-- do not remove! for errors! -->
    <div class="text-center">
      <span style="color:darkred" id="errortext">&nbsp;</span>
    </div>


    <!-- removing muted means Safari (maybe others will be black/worn autoplay) -->
    <!-- you should keep muted attribute present-->
    <!-- controls helps user turn on audio -->

    <div class="text-center">
      <video id="video1" class="" autoplay controls muted width="1024" frameborder="2" allowfullscreen>
      </video>
    </div>

  </div>


  <script>
    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams#examples
    let params = (new URL(document.location)).searchParams;
    //let foo = params.get("name");



    // Wait for the page to load first
    window.onload = function () {
      var a = document.getElementById("gofullscreen")
      a.onclick = function () {
        let video = document.getElementById("video1")
        if (video.requestFullscreen) {
          video.requestFullscreen()
        } else {
          // Toggle fullscreen in Safari for iPad
          video.webkitEnterFullScreen()
        }
        return false
      }

      const xstate = document.getElementById('xstate')
      const vidout = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
      receive(xstate, vidout)
      document.title = "Receiving"
    }
    //The @ts-check statement enables jsdoc typechecking
    // https://stackoverflow.com/a/52076280/86375
    // http://demo.unified-streaming.com/players/dash.js-2.4.1/build/jsdoc/jsdoc_cheat-sheet.pdf
    //@ts-check

    let suburl = location.origin + '/sub'        // output from sfu
    let puburl = location.origin + '/pub'          // input to sfu






    // prior to invoke transmit
    // const gumopts = { video: { width: 1280, height: 720 }, audio: true }
    // const stream = await navigator.mediaDevices.getUserMedia(gumopts)

    // const xvid = /** @type {HTMLVideoElement} */ (document.getElementById('video1'))
    // xvid.srcObject = stream
    // let v=stream.getVideoTracks()[0]
    // let a=stream.getAudioTracks()[0]
    // let pc = transmit(v,a)
    // const xstate = document.getElementById('xstate')
    // pc.onconnectionstatechange = e => xstate.textContent = pc.connectionState
    // while (true) {
    //   document.getElementById('rxtx').textContent = await getRxTxRate(pc)
    //   await new Promise(r => setTimeout(r, 3000))
    //  }


    /**
     * @param {MediaStreamTrack} video The video MST to send using WISH.
     * @param {MediaStreamTrack} audio The audio MST to send using WISH.
     * @returns {RTCPeerConnection}
     */
    async function transmit(video, audio) {
      console.debug("--transmit5")
      document.title = "Sending"


      try {

        //   var t0 = performance.now()
        //console.debug("delay of " + (performance.now() - t0) + "ms")
        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)

        //pc.onicecandidate = event => { console.debug('ignore ice candidate') }

        pc.addTransceiver(video, { 'direction': 'sendonly' })
        pc.addTransceiver(audio, { 'direction': 'sendonly' })

        let desc = await pc.createOffer()
        await pc.setLocalDescription(desc)

        // XXXX consider wrapping with timeout promise
        const t0 = performance.now()
        await waitToCompleteIceGathering(pc)
        desc = pc.localDescription
        console.debug('ice gather blocked for N ms:', Math.ceil(performance.now() - t0))

        console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        let fetchopt =
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/sdp', },
          body: desc.sdp
        }
        let resp = await fetch(puburl, fetchopt)
        let resptext = await resp.text()
        if (resp.status != 202) {
          throw `SFU error: ${resptext} ${resp.status}`
          // pc.close()
          // return
        }
        console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)
        await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        return pc
      } catch (error) {
        console.error('Send Error:', error)
        //document.getElementById('errortext').textContent = error
        alert(error)
      }
    }

    async function sendSignalling(desc) {
      console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
      let fetchopt =
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/sdp', },
        body: desc.sdp
      }
      let resp = await fetch(suburl, fetchopt)
      let resptext = await resp.text()
      if (resp.status != 202) {
        throw `SFU error: ${resptext} ${resp.status}`
        // pc.close()
        // return
      }
      console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)
      return resptext
    }


    function waitToCompleteIceGathering(pc) {
      return new Promise(resolve => {
        setTimeout(function () {
          resolve(pc.localDescription)
        }, 250)
        pc.addEventListener('icegatheringstatechange', e => (e.target.iceGatheringState === 'complete') && resolve(pc.localDescription));
      })
    }

    async function waitToCompleteIceGatheringLog(pc) {
      const t0 = performance.now()
      let x = await waitToCompleteIceGathering(pc)  // XXXX consider wrapping with timeout promise
      console.debug('ice gather blocked for N ms:', Math.ceil(performance.now() - t0))
      return x
    }




    /**
     * @param {HTMLElement} status - The status element .innerText gets updatew.
     * @param {HTMLVideoElement} vidout - The video element for playback
     * @returns {RTCPeerConnection}
     */
    async function receive(status, vidout) {
      console.debug("--receive x3")



      try {
        const url = suburl

        let pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] })
        pc.oniceconnectionstatechange = e => console.debug(pc.iceConnectionState)

        pc.onconnectionstatechange = e => {
          console.debug('>onconnectionstatechange', pc.connectionState)
          status.innerText = pc.connectionState
          if (pc.connectionState === "failed") {
            /* possibly reconfigure the connection in some way here */
            /* then request ICE restart */
            console.debug('restarting ice')
            pc.restartIce()
          }
        }


        let ntry = 0
        pc.onnegotiationneeded = async () => {
          console.debug('onnegotiationneeded')
          await pc.setLocalDescription(await pc.createOffer())
          await waitToCompleteIceGatheringLog(pc)
          let ans = ''
          while (ans === '') {
            try {
              ans = await sendSignalling(pc.localDescription)
            } catch (err) {
              console.log(err)

              status.innerText = ('retrying #' + ntry++)

              await (new Promise(r => setTimeout(r, 2000)))
            }
          }

          await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: ans }))
        }

        //must have addtransceiver to get m=video in sdp
        //addTransceiver() must be called before createOffer()
        pc.addTransceiver('video', { 'direction': 'recvonly' })
        pc.addTransceiver('audio', { 'direction': 'recvonly' })

        pc.ontrack = function (event) {
          let z = event.streams[0]
          console.debug('on track fired naudio', z.getAudioTracks().length)
          console.debug('on track fired nvideo', z.getVideoTracks().length)

          vidout.srcObject = event.streams[0]
          vidout.autoplay = true
          vidout.controls = true
          return false
        }
        // Go!
        pc.restartIce()


        // let desc = await pc.createOffer()
        // await pc.setLocalDescription(desc)
        // // XXXX consider wrapping with timeout promise
        // const t0 = performance.now()
        // await waitToCompleteIceGathering(pc)
        // desc = pc.localDescription
        // console.debug('ice gather blocked for N ms:', Math.ceil(performance.now() - t0))

        // //console.debug('got all ice ms:', performance.now() - t0)

        // console.debug('sending N line offer:', desc.sdp.split(/\r\n|\r|\n/).length)
        // let fetchopt =
        // {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/sdp', },
        //   body: desc.sdp
        // }
        // let resp = await fetch(url, fetchopt)
        // let resptext = await resp.text()
        // if (resp.status != 202) {
        //   throw `SFU error: ${resptext} ${resp.status}`
        //   // pc.close()
        //   // return
        // }
        // console.debug('got N line answer:', resptext.split(/\r\n|\r|\n/).length)
        //;await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: resptext }))

        console.debug('n senders in getsenders()', pc.getSenders())
        //NO NO
        // pc.addTransceiver('audio', { 'direction': 'recvonly' })
        // pc.addTransceiver('video', { 'direction': 'recvonly' })

        while (true) {
          document.getElementById('rxtx').textContent = await getRxTxRate(pc)
          await new Promise(r => setTimeout(r, 3000))
        }


      } catch (error) {
        console.error('Receive Error:', error)
        //document.getElementById('errortext').textContent = error
        alert(error)
      }
    }

    var ratemap = new Map()

    async function getRxTxRate(pc) {
      let rxrate = 0
      let txrate = 0
      try {
        if (typeof ratemap === 'undefined') {
          ratemap = new Map()
        }

        const results = await pc.getStats(null)
        results.forEach(report => {
          const now = report.timestamp


          let xtraDebug = true
          if (xtraDebug) {
            if (report.type === 'inbound-rtp' && report.kind === 'video') {
              console.debug('frames: Nrx', report.framesReceived, 'Ndecode', report.framesDecoded, 'Nrx-Ndecode', report.framesReceived - report.framesDecoded)
            }
          }


          //debugging notes
          // if (typeof report.bytesReceived !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesReceived)
          // }
          // if (typeof report.bytesTransmitted !== 'undefined') {
          //     console.debug(report.type, report.mediaType, report.bytesTransmitted)
          // }

          // NO!: if (report.type === 'outbound-rtp' && report.kind === 'video') {
          // we don't constrain rx/tx rate to just video, we include audio also
          if (report.type === 'outbound-rtp') {
            const bytes = report.bytesSent
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              txrate += bitrate
              //console.debug('tx speed', report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
          if (report.type === 'inbound-rtp') {
            const bytes = report.bytesReceived
            if (ratemap.has(report.ssrc)) { //report.id may also be a good key
              const bytesPrev = ratemap.get(report.ssrc).bytesPrev
              const timestampPrev = ratemap.get(report.ssrc).timestampPrev
              const bitrate = 8 * (bytes - bytesPrev) / (now - timestampPrev);
              rxrate += bitrate
              //console.debug('rx speed',report.ssrc, report.type, report.mediaType, bitrate)
            }
            ratemap.set(report.ssrc, { bytesPrev: bytes, timestampPrev: now })
          }
        })

      } catch (err) {
        console.error(err);
      }
      // we have kbps
      rxrate = Math.floor(rxrate)
      txrate = Math.floor(txrate)

      return `${rxrate}/${txrate} rx/tx kbps`
    }

  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
    crossorigin="anonymous"></script>
</body>

</html>